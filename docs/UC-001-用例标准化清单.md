# UC-001-用例标准化清单

## 用例标准化结果

基于5个关键判断标准，对脑暴阶段识别的用例进行标准化处理，按编译器技术流程组织：

### 1. 改变系统状态判断
**判断标准**: 它改变系统状态吗？
- ✅ **改变状态** → 命令用例 `[C]`
- ❌ **不改变状态** → 查询用例 `[Q]`

**标准化结果**:
```go
// 命令用例（改变状态）- 前端处理阶段
type PerformLexicalAnalysisUseCase struct{}      // 词法分析，生成 Token 序列
type PerformSyntaxAnalysisUseCase struct{}       // 语法分析，构建 AST
type PerformSemanticAnalysisUseCase struct{}     // 语义分析，进行类型检查
type CreateEditSourceFileUseCase struct{}        // 创建/编辑源文件，改变源码状态

// 命令用例（改变状态）- 中端处理阶段
type GenerateIntermediateRepUseCase struct{}     // 生成 IR，改变中间表示
type ApplyMachineIndependentOptUseCase struct{}  // 应用优化，改变 IR 代码

// 命令用例（改变状态）- 后端处理阶段
type GenerateTargetCodeUseCase struct{}          // 生成目标代码，改变汇编输出
type PerformAssemblyUseCase struct{}             // 执行汇编，生成目标文件
type PerformLinkingUseCase struct{}              // 执行链接，生成二进制

// 命令用例（改变状态）- 运行时阶段
type RunDebugProgramUseCase struct{}             // 运行/调试程序，改变进程状态
type ConfigureUseAIFeaturesUseCase struct{}      // 配置 AI 特性，改变 Agent 状态
type ManageEchoProjectUseCase struct{}           // 管理项目，改变项目状态
type DeployApplicationUseCase struct{}           // 部署应用，改变部署状态
type HandleCompilationErrorsUseCase struct{}     // 处理编译错误，改变错误状态

// 查询用例（读取状态）
type AnalyzePerformanceUseCase struct{}          // 分析性能，只读取运行状态
```

### 2. 用户单独执行判断
**判断标准**: 用户会单独执行它吗？

**独立用例** (✅ 会单独执行):
- `PerformLexicalAnalysisUseCase` - 编译器开发者经常单独测试词法分析
- `PerformSyntaxAnalysisUseCase` - 编译器开发者经常单独测试语法分析
- `PerformSemanticAnalysisUseCase` - 编译器开发者经常单独测试语义分析
- `GenerateIntermediateRepUseCase` - 编译器开发者经常单独测试 IR 生成
- `GenerateTargetCodeUseCase` - 编译器开发者经常单独测试代码生成
- `RunDebugProgramUseCase` - 开发者经常单独运行和调试程序
- `AnalyzePerformanceUseCase` - 开发者专门进行性能分析
- `DeployApplicationUseCase` - 开发者专门部署应用
- `HandleCompilationErrorsUseCase` - 开发者专门处理编译错误

**可合并用例** (❌ 不会单独执行):
- 汇编和链接操作 → 通常在完整编译流程中执行，合并到编译流程
- 项目配置子操作 → 合并到 `ManageEchoProjectUseCase`

### 3. 失败处理特殊性判断
**判断标准**: 失败需要特殊处理吗？

**需要特殊处理 → 独立用例**:
- `PerformLexicalAnalysisUseCase` - 词法错误需要语法高亮和位置信息
- `PerformSyntaxAnalysisUseCase` - 语法错误需要 AST 可视化和修复建议
- `PerformSemanticAnalysisUseCase` - 类型错误需要详细类型信息和推断建议
- `GenerateIntermediateRepUseCase` - IR 生成失败需要 LLVM 诊断信息
- `RunDebugProgramUseCase` - 运行时错误需要堆栈跟踪和变量检查
- `HandleCompilationErrorsUseCase` - 编译错误需要分类处理和修复指导

**通用失败处理 → 可合并**:
- 优化失败、汇编失败、链接失败通常使用标准错误处理

### 4. 业务规则独立性判断
**判断标准**: 有独立的业务规则吗？

**有独立规则 → 独立用例**:
```go
type PerformLexicalAnalysisUseCase struct {
    // 词法规则：Token 识别、正则表达式匹配、位置跟踪
    // 规则复杂，需要独立处理
}

type PerformSemanticAnalysisUseCase struct {
    // 类型系统规则：类型推断、作用域检查、类型兼容性
    // 规则复杂且专业
}

type ApplyMachineIndependentOptUseCase struct {
    // 优化规则：常量传播、死代码消除、循环优化策略
    // 规则复杂，需要独立处理
}

type ConfigureAgentUseCase struct {
    // Agent配置规则：状态机定义、消息路由、行为逻辑
    // 业务规则复杂
}
```

**无独立规则 → CRUD操作**:
- 简单文件操作和配置管理无需独立用例

### 5. 调用频度判断
**判断标准**: 会被多个地方调用吗？

**会被多处调用 → 独立用例**:
- `HandleCompilationErrorsUseCase` - 前端、中端、后端各阶段都会遇到错误
- `AnalyzePerformanceUseCase` - 编译时优化、运行时监控、部署后分析都会调用
- `RunDebugProgramUseCase` - 开发调试、集成测试、生产诊断都会需要

**单一调用 → 可简化**:
- 特定编译阶段的专用功能可以适当简化

## 标准化用例列表

### 命令用例 [C] - 改变系统状态

#### 前端处理 (P0) - 编译器核心
- `PerformLexicalAnalysisUseCase` - 执行词法分析，生成 Token 序列
- `PerformSyntaxAnalysisUseCase` - 执行语法分析，构建 AST
- `PerformSemanticAnalysisUseCase` - 执行语义分析，进行类型检查
- `CreateEditSourceFileUseCase` - 创建和编辑 .eo 源文件

#### 中端处理 (P1) - 优化阶段
- `GenerateIntermediateRepUseCase` - 生成 LLVM IR 中间表示
- `ApplyMachineIndependentOptUseCase` - 应用机器无关优化

#### 后端处理 (P0) - 代码生成
- `GenerateTargetCodeUseCase` - 生成目标平台汇编代码
- `PerformAssemblyUseCase` - 执行汇编生成目标文件
- `PerformLinkingUseCase` - 执行链接生成最终二进制

#### 运行时调试 (P0) - 开发者工具
- `RunDebugProgramUseCase` - 运行和调试编译后程序
- `HandleCompilationErrorsUseCase` - 查看和修复编译错误

#### AI特性 (P1) - Echo 独特价值
- `DeployApplicationUseCase` - 部署应用到生产环境

### 查询用例 [Q] - 读取系统状态

#### 项目管理 (P1) - 开发效率
- `ManageEchoProjectUseCase` - 初始化和管理 Echo 项目
- `DeployApplicationUseCase` - 部署应用到目标环境

#### AI特性 (P1) - Echo 独特价值
- `ConfigureUseAIFeaturesUseCase` - 配置和使用 AI Agent 特性

#### 分析功能 (P1) - 质量保证
- `AnalyzePerformanceUseCase` - 分析程序性能指标和运行时状态

### 查询用例 [Q] - 读取系统状态

#### 分析查询 (P1)
- `AnalyzePerformanceUseCase` - 分析程序性能，只读取状态

## 用例命名规则

```
[动词][业务对象]UseCase
```

### 命令用例动词 - 反映编译器技术操作
- Perform: 执行特定编译阶段（如 PerformLexicalAnalysis）
- Generate: 生成中间产物（如 GenerateIntermediateRep）
- Apply: 应用优化或转换（如 ApplyMachineIndependentOpt）
- Create/Edit: 创建或编辑资源（如 CreateEditSourceFile）
- Run/Debug: 运行或调试程序（如 RunDebugProgram）
- Handle: 处理特定问题（如 HandleCompilationErrors）
- Configure: 配置特性（如 ConfigureUseAIFeatures）
- Manage: 管理资源（如 ManageEchoProject）
- Deploy: 部署应用（如 DeployApplication）

### 查询用例动词 - 分析和检查操作
- Analyze: 分析数据和性能（如 AnalyzePerformance）

## 类型标记说明

- `[C]` **命令用例**: 改变系统状态的操作
  - 创建、修改、删除数据
  - 编译、运行、部署程序
  - 配置、设置参数

- `[Q]` **查询用例**: 只读取状态的操作
  - 分析、统计数据
  - 获取、查看信息
  - 检查、验证状态

- `[O]` **编排用例**: 协调多个子操作（暂无）

- `[E]` **事件处理用例**: 处理异步事件（暂无）

## 标准化后的用例清单

| 用例名                    | 类型 | 优先级 | 描述                          |
| ------------------------- | ---- | ------ | ----------------------------- |
| CreateProjectUseCase      | [C]  | P0     | 创建新项目，初始化开发环境    |
| WriteCodeUseCase          | [C]  | P0     | 编写和编辑Echo Language源代码 |
| CompileCodeUseCase        | [C]  | P0     | 编译.my文件为高性能二进制     |
| RunProgramUseCase         | [C]  | P0     | 执行编译后的程序              |
| DebugProgramUseCase       | [C]  | P0     | 调试程序运行和错误            |
| AnalyzePerformanceUseCase | [Q]  | P0     | 分析程序性能指标              |
| UseConcurrencyUseCase     | [C]  | P1     | 使用协程并发特性              |
| ConfigureAgentUseCase     | [C]  | P1     | 配置AI Agent行为模式          |
| DeployApplicationUseCase  | [C]  | P1     | 部署应用到生产环境            |
| ExtendLanguageUseCase     | [C]  | P2     | 扩展语言新特性                |

## 标准化原则总结

1. **状态改变为先**: 优先识别会改变系统状态的操作
2. **用户意图为中心**: 从用户单独执行的可能性判断独立性
3. **错误处理特殊化**: 复杂错误处理需要独立用例
4. **业务规则驱动**: 有独立业务规则的操作需要独立处理
5. **复用性考虑**: 被多处调用的功能优先独立

这9个标准化用例涵盖了Echo Language的核心功能，从项目创建到部署运行，从基础编程到AI特性支持，形成了一个完整的功能集合。
