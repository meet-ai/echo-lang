# UC-001-分层架构设计

## 1. 架构概述

基于限界上下文设计，Echo Language 项目采用经典的 DDD 分层架构，结合六边形架构（Hexagonal Architecture）原则，实现业务逻辑与技术实现的解耦。

### 1.1 架构原则

#### 依赖倒置原则
- 高层模块不依赖低层模块，两者都依赖抽象
- 业务逻辑不依赖技术实现
- 通过依赖注入实现运行时装配

#### 单一职责原则
- 每一层只负责单一关注点
- 层间通过接口通信
- 避免跨层调用

#### 领域驱动设计
- 以业务领域为核心
- 领域逻辑封装在领域层
- 技术实现隔离在基础设施层

### 1.2 分层结构

```
┌─────────────────────────────────────────────────────────────┐
│  Presentation Layer (Web/CLI)                              │
│  - HTTP/GraphQL/CLI 接口处理                                │
│  - 请求解析与响应格式化                                     │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│  Application Layer (Use Cases)                             │
│  - 用例编排与协调                                           │
│  - 事务管理与错误处理                                       │
│  - DTO 输入输出                                             │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│  Domain Layer (Business Rules)                             │
│  - 实体、值对象、领域服务                                    │
│  - 领域事件与聚合根                                         │
│  - 业务规则与不变式                                         │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│  Infrastructure Layer (Technical Details)                 │
│  - 数据持久化、外部服务适配                                 │
│  - 配置管理、日志记录                                       │
│  - 框架与第三方库集成                                       │
└─────────────────────────────────────────────────────────────┘
```

## 2. 各层职责详解

### 2.1 Presentation Layer（展现层）

#### 职责范围
- **接口协议处理**：HTTP/GraphQL/WebSocket/CLI 协议解析
- **请求路由**：根据请求路径分发到对应的应用服务
- **数据序列化**：JSON/XML/Protocol Buffers 编解码
- **认证授权**：请求身份验证和权限检查
- **响应格式化**：统一错误响应和成功响应格式

#### 技术实现
```go
// 展现层示例：HTTP 处理
type CompilerHandler struct {
    compilerService application.CompilerService
}

func (h *CompilerHandler) CompileCode(w http.ResponseWriter, r *http.Request) {
    // 1. 请求解析
    var req CompileRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "invalid request", 400)
        return
    }
    
    // 2. 调用应用服务
    result, err := h.compilerService.CompileCode(r.Context(), req)
    if err != nil {
        // 3. 错误响应格式化
        w.WriteHeader(500)
        json.NewEncoder(w).Encode(ErrorResponse{Error: err.Error()})
        return
    }
    
    // 4. 成功响应格式化
    w.WriteHeader(200)
    json.NewEncoder(w).Encode(result)
}
```

#### 设计约束
- **不包含业务逻辑**：只负责数据转换和路由
- **统一错误处理**：所有错误统一格式返回
- **性能监控**：请求响应时间和错误率监控

### 2.2 Application Layer（应用层）

#### 职责范围
- **用例编排**：将多个领域操作编排成完整的业务用例
- **事务管理**：确保用例执行的原子性和一致性
- **DTO 转换**：领域对象与外部接口的数据转换
- **事件发布**：业务操作完成后发布领域事件
- **安全验证**：输入数据验证和业务规则检查

#### 技术实现
```go
// 应用层示例：编译代码用例
type CompileCodeUseCase struct {
    compilerRepo     domain.CompilerRepository
    validator        domain.CodeValidator
    eventPublisher   domain.EventPublisher
    transactionMgr   infrastructure.TransactionManager
}

func (uc *CompileCodeUseCase) Execute(ctx context.Context, req CompileCodeRequest) (*CompileCodeResponse, error) {
    // 1. 输入验证
    if err := uc.validator.ValidateCode(req.Code); err != nil {
        return nil, fmt.Errorf("code validation failed: %w", err)
    }
    
    // 2. 事务开始
    tx := uc.transactionMgr.BeginTransaction()
    defer tx.Rollback()
    
    // 3. 调用领域服务
    result, err := uc.compilerRepo.Compile(ctx, req.Code, req.Target)
    if err != nil {
        return nil, fmt.Errorf("compilation failed: %w", err)
    }
    
    // 4. 保存编译结果
    if err := uc.compilerRepo.SaveResult(ctx, result); err != nil {
        return nil, fmt.Errorf("save result failed: %w", err)
    }
    
    // 5. 发布领域事件
    event := domain.CodeCompiledEvent{
        CodeID:   result.ID,
        Target:   req.Target,
        CompiledAt: time.Now(),
    }
    if err := uc.eventPublisher.Publish(ctx, event); err != nil {
        // 事件发布失败不影响主流程
        log.Printf("failed to publish event: %v", err)
    }
    
    // 6. 事务提交
    if err := tx.Commit(); err != nil {
        return nil, fmt.Errorf("transaction commit failed: %w", err)
    }
    
    // 7. 返回DTO
    return &CompileCodeResponse{
        CodeID:     result.ID,
        BinaryPath: result.BinaryPath,
        CompiledAt: result.CompiledAt,
    }, nil
}
```

#### 设计约束
- **无领域逻辑**：不包含业务规则判断
- **协调职责**：只负责调用领域服务和基础设施
- **错误处理**：统一错误处理和转换
- **性能考虑**：避免在应用层进行复杂计算

### 2.3 Domain Layer（领域层）

#### 职责范围
- **业务实体**：带有业务行为的领域对象
- **值对象**：不可变的数据描述对象
- **领域服务**：跨实体的业务逻辑
- **聚合根**：聚合边界的定义和一致性保证
- **领域事件**：业务状态变化的通知
- **仓储接口**：数据访问的抽象定义

#### 实体设计示例
```go
// 领域层示例：编译任务实体
type CompilationTask struct {
    id           string
    sourceCode   string
    target       CompileTarget
    status       CompilationStatus
    result       *CompilationResult
    createdAt    time.Time
    completedAt  *time.Time
    errors       []CompilationError
}

// 业务方法：开始编译
func (t *CompilationTask) StartCompilation() error {
    if t.status != CompilationStatusPending {
        return fmt.Errorf("task is not in pending status")
    }
    
    t.status = CompilationStatusCompiling
    return nil
}

// 业务方法：完成编译
func (t *CompilationTask) CompleteCompilation(result CompilationResult) {
    t.status = CompilationStatusCompleted
    t.result = &result
    now := time.Now()
    t.completedAt = &now
}

// 业务方法：失败处理
func (t *CompilationTask) FailCompilation(errors []CompilationError) {
    t.status = CompilationStatusFailed
    t.errors = errors
    now := time.Now()
    t.completedAt = &now
}
```

#### 值对象设计示例
```go
// 领域层示例：编译目标值对象
type CompileTarget struct {
    platform string
    arch     string
    os       string
}

func NewCompileTarget(platform, arch, os string) (CompileTarget, error) {
    // 验证平台支持性
    if !isSupportedPlatform(platform) {
        return CompileTarget{}, fmt.Errorf("unsupported platform: %s", platform)
    }
    
    return CompileTarget{
        platform: platform,
        arch:     arch,
        os:       os,
    }, nil
}

// 值对象方法：获取目标字符串
func (t CompileTarget) String() string {
    return fmt.Sprintf("%s-%s-%s", t.platform, t.arch, t.os)
}

// 值对象方法：检查兼容性
func (t CompileTarget) IsCompatible(other CompileTarget) bool {
    return t.platform == other.platform && t.arch == other.arch
}
```

#### 领域服务设计示例
```go
// 领域层示例：编译服务
type CompilationService interface {
    Compile(ctx context.Context, task CompilationTask) (*CompilationResult, error)
    ValidateCode(code string) error
}

// 领域服务实现
type compilationService struct {
    lexer    Lexer
    parser   Parser
    analyzer SemanticAnalyzer
    generator CodeGenerator
}

func (s *compilationService) Compile(ctx context.Context, task CompilationTask) (*CompilationResult, error) {
    // 1. 词法分析
    tokens, err := s.lexer.Tokenize(task.SourceCode())
    if err != nil {
        return nil, fmt.Errorf("lexical analysis failed: %w", err)
    }
    
    // 2. 语法分析
    ast, err := s.parser.Parse(tokens)
    if err != nil {
        return nil, fmt.Errorf("syntax analysis failed: %w", err)
    }
    
    // 3. 语义分析
    analyzedAST, err := s.analyzer.Analyze(ast)
    if err != nil {
        return nil, fmt.Errorf("semantic analysis failed: %w", err)
    }
    
    // 4. 代码生成
    ocamlCode, err := s.generator.Generate(analyzedAST)
    if err != nil {
        return nil, fmt.Errorf("code generation failed: %w", err)
    }
    
    return &CompilationResult{
        AST:       analyzedAST,
        OCamlCode: ocamlCode,
        Target:    task.Target(),
    }, nil
}
```

#### 仓储接口设计示例
```go
// 领域层示例：编译任务仓储接口
type CompilationTaskRepository interface {
    Save(ctx context.Context, task CompilationTask) error
    FindByID(ctx context.Context, id string) (CompilationTask, error)
    FindByStatus(ctx context.Context, status CompilationStatus) ([]CompilationTask, error)
    Update(ctx context.Context, task CompilationTask) error
    Delete(ctx context.Context, id string) error
}

// 领域事件定义
type CodeCompiledEvent struct {
    TaskID     string    `json:"task_id"`
    Target     CompileTarget `json:"target"`
    Success    bool      `json:"success"`
    CompiledAt time.Time `json:"compiled_at"`
    BinarySize int64     `json:"binary_size,omitempty"`
    Errors     []string  `json:"errors,omitempty"`
}

func (e CodeCompiledEvent) EventType() string {
    return "code.compiled"
}

func (e CodeCompiledEvent) AggregateID() string {
    return e.TaskID
}
```

#### 设计约束
- **业务逻辑集中**：所有业务规则和行为封装在领域层
- **技术无关**：不依赖具体技术实现
- **测试友好**：领域对象易于单元测试
- **聚合一致性**：聚合根保证业务一致性边界

### 2.4 Infrastructure Layer（基础设施层）

#### 职责范围
- **数据持久化**：数据库、缓存、文件系统的操作
- **外部服务集成**：第三方API、消息队列、搜索引擎
- **技术框架适配**：ORM、HTTP客户端、序列化库
- **配置管理**：环境变量、配置文件、配置中心
- **监控与日志**：指标收集、日志记录、追踪系统

#### 技术实现示例
```go
// 基础设施层示例：编译任务仓储实现
type compilationTaskRepositoryGORM struct {
    db *gorm.DB
}

func NewCompilationTaskRepositoryGORM(db *gorm.DB) domain.CompilationTaskRepository {
    return &compilationTaskRepositoryGORM{db: db}
}

func (r *compilationTaskRepositoryGORM) Save(ctx context.Context, task domain.CompilationTask) error {
    // 领域对象转换为数据库模型
    model := toCompilationTaskModel(task)
    
    // 数据库操作
    result := r.db.WithContext(ctx).Create(&model)
    if result.Error != nil {
        return fmt.Errorf("failed to save compilation task: %w", result.Error)
    }
    
    return nil
}

func (r *compilationTaskRepositoryGORM) FindByID(ctx context.Context, id string) (domain.CompilationTask, error) {
    var model CompilationTaskModel
    
    result := r.db.WithContext(ctx).First(&model, "id = ?", id)
    if result.Error != nil {
        if errors.Is(result.Error, gorm.ErrRecordNotFound) {
            return domain.CompilationTask{}, fmt.Errorf("compilation task not found: %s", id)
        }
        return domain.CompilationTask{}, fmt.Errorf("failed to find compilation task: %w", result.Error)
    }
    
    // 数据库模型转换为领域对象
    task := fromCompilationTaskModel(model)
    return task, nil
}

// 数据库模型（仅基础设施层）
type CompilationTaskModel struct {
    ID          string    `gorm:"primaryKey"`
    SourceCode  string    `gorm:"type:text"`
    Target      string    `gorm:"size:100"`
    Status      string    `gorm:"size:20"`
    Result      string    `gorm:"type:text"`
    CreatedAt   time.Time
    CompletedAt *time.Time
    Errors      string    `gorm:"type:text"`
}

// 模型转换函数
func toCompilationTaskModel(task domain.CompilationTask) CompilationTaskModel {
    // 领域对象 → 数据库模型的转换
    // 处理值对象序列化等
}

func fromCompilationTaskModel(model CompilationTaskModel) domain.CompilationTask {
    // 数据库模型 → 领域对象的转换
    // 处理值对象反序列化等
}
```

#### OCaml编译器集成示例
```go
// 基础设施层示例：OCaml编译器适配器
type OCamlCompilerAdapter struct {
    compilerPath string
    tempDir      string
}

func NewOCamlCompilerAdapter(compilerPath, tempDir string) domain.Compiler {
    return &OCamlCompilerAdapter{
        compilerPath: compilerPath,
        tempDir:      tempDir,
    }
}

func (c *OCamlCompilerAdapter) Compile(ctx context.Context, ocamlCode string, target domain.CompileTarget) (*domain.CompilationResult, error) {
    // 1. 创建临时文件
    sourceFile, err := c.createTempFile("source.ml", ocamlCode)
    if err != nil {
        return nil, fmt.Errorf("failed to create source file: %w", err)
    }
    defer os.Remove(sourceFile)
    
    // 2. 构建编译命令
    binaryFile := filepath.Join(c.tempDir, "output")
    cmd := exec.CommandContext(ctx, c.compilerPath, 
        "-o", binaryFile,  // 输出文件
        sourceFile,        // 输入文件
    )
    
    // 3. 执行编译
    output, err := cmd.CombinedOutput()
    if err != nil {
        return nil, &domain.CompilationError{
            Type:    domain.CompilationErrorTypeCompiler,
            Message: string(output),
            Code:    ocamlCode,
        }
    }
    
    // 4. 验证输出文件
    if _, err := os.Stat(binaryFile); os.IsNotExist(err) {
        return nil, fmt.Errorf("compiler did not produce output file")
    }
    
    // 5. 返回编译结果
    return &domain.CompilationResult{
        BinaryPath: binaryFile,
        Target:     target,
        CompiledAt: time.Now(),
    }, nil
}
```

#### 设计约束
- **接口实现**：基础设施层实现领域层定义的接口
- **依赖注入**：通过DI容器注入到应用层
- **错误处理**：将技术异常转换为领域异常
- **配置外部化**：配置通过环境变量或配置文件注入

## 3. 层间通信机制

### 3.1 接口定义原则

#### 领域层接口
```go
// 领域层：定义业务接口
type Compiler interface {
    Compile(ctx context.Context, task CompilationTask) (*CompilationResult, error)
}

type CompilationTaskRepository interface {
    Save(ctx context.Context, task CompilationTask) error
    FindByID(ctx context.Context, id string) (CompilationTask, error)
}
```

#### 应用层使用
```go
// 应用层：依赖领域接口
type CompileCodeUseCase struct {
    compiler Compiler                    // 领域接口
    repo     CompilationTaskRepository  // 领域接口
}
```

#### 基础设施实现
```go
// 基础设施层：实现领域接口
type ocamlCompiler struct {
    compilerPath string
}

func (c *ocamlCompiler) Compile(ctx context.Context, task domain.CompilationTask) (*domain.CompilationResult, error) {
    // 具体实现
}
```

### 3.2 数据传输对象（DTO）

#### 输入DTO
```go
// 应用层：输入DTO
type CompileCodeRequest struct {
    Code   string `json:"code" validate:"required"`
    Target string `json:"target" validate:"required,oneof=linux windows darwin"`
}
```

#### 输出DTO
```go
// 应用层：输出DTO
type CompileCodeResponse struct {
    TaskID     string    `json:"task_id"`
    BinaryPath string    `json:"binary_path"`
    CompiledAt time.Time `json:"compiled_at"`
}
```

#### 转换逻辑
```go
// 应用层：DTO与领域对象转换
func (uc *CompileCodeUseCase) Execute(ctx context.Context, req CompileCodeRequest) (*CompileCodeResponse, error) {
    // DTO → 领域对象
    target, err := domain.NewCompileTarget(req.Target)
    if err != nil {
        return nil, err
    }
    
    task := domain.NewCompilationTask(req.Code, target)
    
    // 调用领域服务
    result, err := uc.compiler.Compile(ctx, task)
    if err != nil {
        return nil, err
    }
    
    // 领域对象 → DTO
    return &CompileCodeResponse{
        TaskID:     result.TaskID,
        BinaryPath: result.BinaryPath,
        CompiledAt: result.CompiledAt,
    }, nil
}
```

## 4. 依赖注入架构

### 4.1 容器配置

#### 应用层注册
```go
// internal/infrastructure/di/application_providers.go
func RegisterApplicationProviders(container *do.Injector) error {
    // 应用服务
    do.Provide(container, func(i *do.Injector) application.CompilerService {
        compiler := do.MustInvoke[domain.Compiler](i)
        repo := do.MustInvoke[domain.CompilationTaskRepository](i)
        return application.NewCompilerService(compiler, repo)
    })
    
    return nil
}
```

#### 领域层注册
```go
// internal/infrastructure/di/domain_providers.go
func RegisterDomainProviders(container *do.Injector) error {
    // 领域服务
    do.Provide(container, func(i *do.Injector) domain.Compiler {
        return domain.NewCompilationService()
    })
    
    return nil
}
```

#### 基础设施层注册
```go
// internal/infrastructure/di/infrastructure_providers.go
func RegisterInfrastructureProviders(container *do.Injector, cfg *config.Config) error {
    // 仓储实现
    do.Provide(container, func(i *do.Injector) domain.CompilationTaskRepository {
        db := do.MustInvoke[*gorm.DB](i)
        return infrastructure.NewCompilationTaskRepositoryGORM(db)
    })
    
    // 编译器适配器
    do.Provide(container, func(i *do.Injector) domain.Compiler {
        return infrastructure.NewOCamlCompilerAdapter(cfg.OCaml.Path, cfg.TempDir)
    })
    
    return nil
}
```

### 4.2 容器组装

#### 主容器创建
```go
// cmd/main.go
func main() {
    // 配置加载
    cfg, err := config.Load()
    if err != nil {
        log.Fatal(err)
    }
    
    // 创建DI容器
    container := di.NewContainer(cfg)
    
    // 启动应用
    app := application.NewApp(container)
    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}

// internal/infrastructure/di/container.go
func NewContainer(cfg *config.Config) *do.Injector {
    container := do.New()
    
    // 基础组件
    do.Provide(container, func(i *do.Injector) *config.Config {
        return cfg
    })
    
    // 注册各层提供者
    if err := RegisterInfrastructureProviders(container, cfg); err != nil {
        panic(err)
    }
    if err := RegisterDomainProviders(container); err != nil {
        panic(err)
    }
    if err := RegisterApplicationProviders(container); err != nil {
        panic(err)
    }
    
    return container
}
```

## 5. 架构约束与设计模式

### 5.1 架构约束

#### 依赖方向约束
```
Presentation Layer → Application Layer → Domain Layer ← Infrastructure Layer
                      ↑                        ↓
                   Ports ←───────────────── Adapters
```

#### 包导入约束
- **Presentation**：只能导入 Application、共享库
- **Application**：只能导入 Domain、共享库
- **Domain**：只能导入自身、标准库、值对象库
- **Infrastructure**：可以导入所有层，但主要实现 Domain 接口

#### 循环依赖禁止
- 任何层都不能反向导入更高层
- 基础设施层不能相互依赖，只能依赖共享组件

### 5.2 设计模式应用

#### 依赖倒置模式
```go
// 高层模块定义接口
type Compiler interface {
    Compile(ctx context.Context, task CompilationTask) (*CompilationResult, error)
}

// 低层模块实现接口
type ocamlCompiler struct{}

func (c *ocamlCompiler) Compile(ctx context.Context, task CompilationTask) (*CompilationResult, error) {
    // 具体实现
}
```

#### 工厂模式
```go
// 领域对象工厂
func NewCompilationTask(code string, target CompileTarget) (CompilationTask, error) {
    // 创建逻辑和验证
}

// 基础设施工厂
func NewOCamlCompilerAdapter(path, tempDir string) Compiler {
    // 创建具体实现
}
```

#### 适配器模式
```go
// 适配器实现领域接口
type OCamlCompilerAdapter struct {
    compilerPath string
    tempDir      string
}

func (a *OCamlCompilerAdapter) Compile(ctx context.Context, task CompilationTask) (*CompilationResult, error) {
    // 适配 OCaml 编译器 API 到领域接口
}
```

## 6. 测试策略

### 6.1 单元测试

#### 领域层测试
```go
func TestCompilationTask_StartCompilation(t *testing.T) {
    task := domain.NewCompilationTask("print \"hello\"", domain.LinuxTarget)
    
    err := task.StartCompilation()
    
    assert.NoError(t, err)
    assert.Equal(t, domain.CompilationStatusCompiling, task.Status())
}
```

#### 应用层测试
```go
func TestCompileCodeUseCase_Execute(t *testing.T) {
    // Mock 领域服务
    mockCompiler := &mocks.Compiler{}
    mockRepo := &mocks.CompilationTaskRepository{}
    
    useCase := application.NewCompileCodeUseCase(mockCompiler, mockRepo)
    
    // 测试执行
    result, err := useCase.Execute(context.Background(), CompileCodeRequest{
        Code:   "print \"hello\"",
        Target: "linux",
    })
    
    assert.NoError(t, err)
    assert.NotNil(t, result)
}
```

### 6.2 集成测试

#### 基础设施集成测试
```go
func TestCompilationTaskRepositoryGORM_SaveAndFind(t *testing.T) {
    // 使用 testcontainers 启动 PostgreSQL
    ctx := context.Background()
    postgresContainer, err := testcontainers.StartPostgresContainer(ctx)
    require.NoError(t, err)
    defer postgresContainer.Terminate(ctx)
    
    // 创建仓库实例
    db := postgresContainer.GetDB()
    repo := infrastructure.NewCompilationTaskRepositoryGORM(db)
    
    // 测试保存和查询
    task := domain.NewCompilationTask("test code", domain.LinuxTarget)
    err = repo.Save(ctx, task)
    assert.NoError(t, err)
    
    found, err := repo.FindByID(ctx, task.ID())
    assert.NoError(t, err)
    assert.Equal(t, task.ID(), found.ID())
}
```

### 6.3 端到端测试

#### API 端到端测试
```go
func TestCompileCodeAPI(t *testing.T) {
    // 启动测试服务器
    app := testhelpers.StartTestApp(t)
    defer app.Stop()
    
    // 发送 HTTP 请求
    req := CompileCodeRequest{
        Code:   "print \"hello world\"",
        Target: "linux-x64",
    }
    
    resp := app.Post("/api/compile", req)
    
    // 验证响应
    assert.Equal(t, 200, resp.StatusCode)
    
    var result CompileCodeResponse
    err := json.Unmarshal(resp.Body, &result)
    assert.NoError(t, err)
    assert.NotEmpty(t, result.TaskID)
}
```

## 7. 性能与可扩展性考虑

### 7.1 性能优化点

#### 编译缓存
- AST 缓存：避免重复解析
- 增量编译：只编译变更部分
- 分布式编译：支持多机并行编译

#### 内存管理
- 对象池：复用频繁创建的对象
- 垃圾回收调优：针对编译器的内存模式优化
- 内存限制：防止编译过程耗尽内存

#### 并发处理
- 请求并发：应用层支持并发请求
- 编译并发：多个编译任务并行执行
- IO 优化：异步文件读写

### 7.2 可扩展性设计

#### 插件架构
- 编译器后端可插拔：支持多种目标语言
- 语言特性扩展：插件化添加新语法
- 工具链集成：支持第三方工具集成

#### 分布式部署
- 编译服务集群：分布式编译能力
- 缓存共享：跨实例编译缓存
- 负载均衡：编译请求分发

#### 配置管理
- 环境隔离：多环境配置管理
- 动态配置：运行时配置更新
- 配置验证：配置正确性检查

## 8. 监控与可观测性

### 8.1 指标收集

#### 业务指标
- 编译成功率
- 平均编译时间
- 编译任务队列长度
- 用户活跃度

#### 技术指标
- CPU 使用率
- 内存使用量
- 磁盘 IO
- 网络延迟

### 8.2 日志分层

#### 应用层日志
```go
// 应用层：业务操作日志
log.Info("starting code compilation", 
    zap.String("task_id", taskID),
    zap.String("target", target.String()))
```

#### 领域层日志
```go
// 领域层：业务状态变化日志
task.StartCompilation()
log.Info("compilation task started", 
    zap.String("task_id", task.ID()))
```

#### 基础设施层日志
```go
// 基础设施层：技术操作日志
result := db.Create(&model)
log.Debug("database operation completed",
    zap.String("table", "compilation_tasks"),
    zap.Int64("rows_affected", result.RowsAffected))
```

### 8.3 分布式追踪

#### 请求追踪
```go
func (h *CompilerHandler) CompileCode(w http.ResponseWriter, r *http.Request) {
    ctx, span := tracer.Start(r.Context(), "CompileCode")
    defer span.End()
    
    // 在上下文中传递 span
    result, err := h.compilerService.CompileCode(ctx, req)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    }
}
```

## 9. 架构演进路线

### 阶段1：基础架构（3个月）
- 完善四层架构
- 实现核心编译功能
- 建立基础监控

### 阶段2：功能扩展（6个月）
- AI特性深度集成
- 性能分析工具增强
- 多目标语言支持

### 阶段3：生态建设（12个月）
- 插件系统开发
- 第三方集成支持
- 社区工具链完善

### 阶段4：企业级特性（18个月）
- 分布式编译支持
- 企业安全合规
- 商业化服务

## 10. 总结

Echo Language 的分层架构设计遵循了 DDD 和六边形架构的核心原则：

### 核心优势
1. **业务逻辑集中**：领域层封装核心业务规则
2. **技术实现隔离**：基础设施层处理技术细节
3. **依赖倒置**：高层不依赖低层，通过接口解耦
4. **测试友好**：各层独立测试，提高质量
5. **演进灵活**：技术栈替换不影响业务逻辑

### 设计亮点
1. **OCaml 集成**：通过基础设施层适配器优雅集成 OCaml 编译器
2. **AI 原生支持**：领域层设计考虑 AI Agent 编程模式
3. **现代化并发**：协程模型在领域层抽象，基础设施层实现
4. **类型安全**：编译时类型检查保证运行时安全

### 实施要点
1. **严格分层**：禁止跨层依赖和循环引用
2. **接口驱动**：所有层间通信通过接口
3. **依赖注入**：运行时装配各层组件
4. **持续测试**：各层独立测试保证质量
5. **监控先行**：架构设计时就考虑可观测性

这个分层架构为 Echo Language 的长期发展奠定了坚实的基础，既保证了技术先进性，又确保了业务逻辑的稳定性和可维护性。
