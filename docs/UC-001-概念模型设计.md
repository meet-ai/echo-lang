# UC-001-概念模型设计

## 1. 概述

基于用例分析和限界上下文设计，本文档定义了Echo Language的核心领域概念模型。这些概念模型是业务领域知识的形式化表达，为后续的领域对象设计和代码实现提供指导。

## 2. 核心概念模型

### 2.1 CompilerContext（编译器上下文）

#### 主要概念

**CompilationTask（编译任务）**
- **定义**: 一次编译过程的完整描述和状态跟踪
- **属性**:
  - 唯一标识ID
  - 源代码内容
  - 编译目标平台
  - 当前编译状态
  - 编译结果或错误信息
  - 创建和完成时间戳
- **行为**:
  - 开始编译
  - 完成编译
  - 失败处理
- **业务规则**:
  - 每个任务必须有唯一的ID
  - 状态转换必须遵循定义的生命周期
  - 编译完成后必须有明确的成功或失败结果

**SourceFile（源文件）**
- **定义**: Echo Language源代码文件的管理和解析
- **属性**:
  - 文件路径
  - 文件内容（.eo 格式）
  - 解析状态
  - 关联的编译任务
- **行为**:
  - 读取文件内容
  - 验证文件格式
  - 关联编译任务
- **业务规则**:
  - 文件必须存在且可读
  - 内容必须是有效的Echo Language语法（.eo 格式）

**CompileTarget（编译目标）**
- **定义**: 编译输出的目标平台和架构规格
- **属性**:
  - 操作系统
  - CPU架构
  - 优化级别
- **行为**:
  - 验证平台兼容性
  - 生成目标字符串
- **不变式**:
  - 必须是受支持的平台组合
  - 一旦创建不可修改

**CompilationResult（编译结果）**
- **定义**: 编译过程的最终输出，包括生成的IR、二进制路径和任何警告/错误
- **属性**:
  - 成功/失败状态
  - 生成的中间表示（IR）文件路径（可选）
  - 二进制文件路径（可选）
  - 警告列表
  - 错误列表
  - 编译耗时
  - 生成时间戳
- **行为**:
  - IsSuccessful()：判断编译是否成功
  - AddWarning(msg string)：添加警告信息
  - AddError(msg string)：添加错误信息
  - GetDuration()：获取编译耗时
- **不变式**:
  - 如果成功，二进制路径必须有效
  - 如果失败，错误列表不为空
  - 所有时间戳必须是有效的过去时间

#### 概念关系图

```
CompilationTask 1:N SourceFile
CompilationTask 1:1 CompileTarget
CompilationTask 1:1 CompilationResult
```

### 2.2 RuntimeContext（运行时上下文）

#### 主要概念

**Process（进程）**
- **定义**: 编译后二进制文件的执行实例
- **属性**:
  - 进程ID
  - 执行状态
  - 资源使用情况
  - 关联的编译任务
- **行为**:
  - 启动执行
  - 暂停/恢复
  - 终止执行
  - 资源监控
- **业务规则**:
  - 进程必须关联有效的编译任务
  - 资源使用不能超过系统限制

**DebugSession（调试会话）**
- **定义**: 程序调试过程的管理
- **属性**:
  - 会话ID
  - 断点列表
  - 当前执行位置
  - 变量状态
- **行为**:
  - 设置断点
  - 单步执行
  - 检查变量值
  - 继续执行
- **业务规则**:
  - 调试会话必须关联正在运行的进程
  - 断点位置必须在有效代码范围内

**MemoryManager（内存管理器）**
- **定义**: 运行时内存分配和垃圾回收的管理
- **属性**:
  - 堆大小
  - GC统计信息
  - 内存分配计数
- **行为**:
  - 分配内存
  - 触发GC
  - 内存使用统计
- **业务规则**:
  - 内存分配不能超过限制
  - GC必须及时清理无用对象

#### 概念关系图

```
Process 1:1 MemoryManager
Process 0:1 DebugSession
DebugSession 1:N Breakpoint
```

### 2.3 AIContext（AI特性上下文）

#### 主要概念

**Agent（智能代理）**
- **定义**: AI驱动的自主执行实体
- **属性**:
  - 代理ID
  - 当前状态
  - 配置参数
  - 执行历史
- **行为**:
  - 初始化配置
  - 状态转换
  - 执行决策
  - 学习更新
- **业务规则**:
  - Agent必须有明确的职责范围
  - 状态转换必须遵循定义的生命周期

**StateMachine（状态机）**
- **定义**: Agent行为的状态转换管理
- **属性**:
  - 当前状态
  - 状态转换规则
  - 事件触发器
- **行为**:
  - 处理事件
  - 执行状态转换
  - 触发动作
- **业务规则**:
  - 状态转换必须有明确的事件触发
  - 不允许无效状态转换

**Message（消息）**
- **定义**: Agent间或与外部系统的通信载体
- **属性**:
  - 消息ID
  - 发送者
  - 接收者
  - 消息类型
  - 消息内容
- **行为**:
  - 序列化/反序列化
  - 路由分发
  - 内容验证
- **业务规则**:
  - 消息必须有明确的发送者和接收者
  - 内容必须符合消息类型规范

#### 概念关系图

```
Agent 1:1 StateMachine
Agent 1:N Message (发送)
Agent 1:N Message (接收)
StateMachine 1:N StateTransition
```

### 2.4 ProjectContext（项目管理上下文）

#### 主要概念

**Project（项目）**
- **定义**: Echo Language项目的组织和管理单元
- **属性**:
  - 项目ID
  - 项目名称
  - 项目类型
  - 源文件列表
  - 配置信息
- **行为**:
  - 添加源文件
  - 更新配置
  - 验证完整性
- **业务规则**:
  - 项目必须有唯一的名称
  - 至少包含一个有效的源文件

**Deployment（部署）**
- **定义**: 项目编译结果的部署和管理
- **属性**:
  - 部署ID
  - 部署目标
  - 部署状态
  - 部署时间
- **行为**:
  - 执行部署
  - 回滚部署
  - 监控状态
- **业务规则**:
  - 部署必须关联有效的编译结果
  - 部署状态必须准确反映实际状态

#### 概念关系图

```
Project 1:N SourceFile
Project 1:N Deployment
Deployment 1:1 CompilationResult
```

### 2.5 AnalysisContext（分析工具上下文）

#### 主要概念

**AnalysisSession（分析会话）**
- **定义**: 一次性能分析或代码分析过程
- **属性**:
  - 会话ID
  - 分析类型
  - 目标对象
  - 分析结果
- **行为**:
  - 开始分析
  - 执行分析逻辑
  - 生成报告
- **业务规则**:
  - 分析会话必须指定明确的分析目标
  - 结果必须包含完整的分析数据

**Metric（指标）**
- **定义**: 系统运行时收集的性能或质量指标
- **属性**:
  - 指标名称
  - 指标值
  - 收集时间
  - 指标类型
- **行为**:
  - 值验证
  - 格式化显示
  - 趋势分析
- **业务规则**:
  - 指标值必须在有效范围内
  - 时间戳必须准确

#### 概念关系图

```
AnalysisSession 1:N Metric
AnalysisSession 1:1 AnalysisReport
```

## 3. 概念统一语言

### 3.1 术语定义

| 术语     | 定义                        | 上下文          | 英文            |
| -------- | --------------------------- | --------------- | --------------- |
| 编译任务 | 一次完整的编译过程          | CompilerContext | CompilationTask |
| 源文件   | 包含Echo Language代码的文件 | CompilerContext | SourceFile      |
| 编译目标 | 编译输出的平台和架构        | CompilerContext | CompileTarget   |
| 进程     | 运行中的程序实例            | RuntimeContext  | Process         |
| 调试会话 | 程序调试过程                | RuntimeContext  | DebugSession    |
| 智能代理 | AI驱动的执行实体            | AIContext       | Agent           |
| 状态机   | 状态转换管理器              | AIContext       | StateMachine    |
| 项目     | 代码组织的单元              | ProjectContext  | Project         |
| 部署     | 程序发布过程                | ProjectContext  | Deployment      |
| 分析会话 | 性能分析过程                | AnalysisContext | AnalysisSession |

### 3.2 概念约束

#### 状态一致性
- 所有实体的状态转换必须遵循业务规则
- 状态变更必须通过领域方法进行
- 状态变更必须发布相应领域事件

#### 标识唯一性
- 每个聚合根必须有全局唯一的标识
- 标识在实体生命周期内保持不变
- 标识用于区分不同的实体实例

#### 值对象不可变性
- 值对象一旦创建，其属性不可修改
- 值对象通过属性值进行比较
- 值对象可以作为实体的属性

## 4. 领域事件模型

### 4.1 CompilerContext 事件

- **CodeCompiled**: 代码编译完成
- **CompilationStarted**: 编译过程开始
- **CompilationFailed**: 编译过程失败

### 4.2 RuntimeContext 事件

- **ProcessStarted**: 进程启动
- **ProcessTerminated**: 进程终止
- **DebugSessionCreated**: 调试会话创建

### 4.3 AIContext 事件

- **AgentCreated**: Agent创建
- **AgentStateChanged**: Agent状态变更
- **MessageSent**: 消息发送

### 4.4 ProjectContext 事件

- **ProjectCreated**: 项目创建
- **DeploymentStarted**: 部署开始
- **DeploymentCompleted**: 部署完成

### 4.5 AnalysisContext 事件

- **AnalysisStarted**: 分析开始
- **AnalysisCompleted**: 分析完成
- **ThresholdExceeded**: 阈值超标

## 5. 聚合设计

### 5.1 CompilationTask 聚合

**聚合根**: CompilationTask
**包含实体**:
- SourceFile（源文件）
- CompilationResult（编译结果）

**聚合边界**:
- 编译任务及其直接相关的源文件和结果
- 保证编译过程的一致性

**业务规则**:
- 一个编译任务可以包含多个源文件
- 编译结果必须与任务关联

### 5.2 Process 聚合

**聚合根**: Process
**包含实体**:
- DebugSession（调试会话）
- MemoryManager（内存管理器）

**聚合边界**:
- 运行中的进程及其调试和内存管理
- 保证运行时状态的一致性

**业务规则**:
- 一个进程只能有一个活动的调试会话
- 内存管理器负责进程的内存分配

### 5.3 Agent 聚合

**聚合根**: Agent
**包含实体**:
- StateMachine（状态机）
- Message[]（消息列表）

**聚合边界**:
- Agent及其状态管理和通信记录
- 保证Agent行为的一致性

**业务规则**:
- Agent状态转换必须通过状态机
- 消息必须与Agent关联

### 5.4 Project 聚合

**聚合根**: Project
**包含实体**:
- SourceFile[]（源文件列表）
- Deployment[]（部署记录）

**聚合边界**:
- 项目及其包含的文件和部署历史
- 保证项目状态的一致性

**业务规则**:
- 项目必须至少包含一个源文件
- 部署记录不可删除

### 5.5 AnalysisSession 聚合

**聚合根**: AnalysisSession
**包含实体**:
- Metric[]（指标数据）

**聚合边界**:
- 分析会话及其收集的指标
- 保证分析过程的一致性

**业务规则**:
- 分析会话必须有明确的分析目标
- 指标数据不可篡改

## 6. 领域服务设计

### 6.1 CompilationService（编译服务）

**职责**:
- 协调词法分析、语法分析、语义分析、中间表示生成
- 管理编译流程的状态转换（前端→中端→后端）
- 调用 OCaml 编译器和 LLVM 工具链
- 处理编译错误和异常

**接口设计**:
```go
type CompilationService interface {
    Compile(ctx context.Context, task CompilationTask) (*CompilationResult, error)
    LexicalAnalysis(sourceCode string) ([]Token, error)
    SyntaxAnalysis(tokens []Token) (AST, error)
    SemanticAnalysis(ast AST) (DecoratedAST, error)
    GenerateIR(ast DecoratedAST) (string, error)  // 生成 LLVM IR
    OptimizeIR(irCode string) (string, error)      // 调用 LLVM opt
    GenerateAssembly(irCode string, target CompileTarget) (string, error)  // 调用 llc
    Link(binaryPath string, objectFiles []string) error  // 调用 clang/ld
}
```

### 6.2 ExecutionService（执行服务）

**职责**:
- 管理进程的创建、执行和销毁
- 协调内存管理和垃圾回收
- 处理运行时异常

**接口设计**:
```go
type ExecutionService interface {
    StartProcess(ctx context.Context, binaryPath string, args []string) (*Process, error)
    StopProcess(ctx context.Context, processID string) error
    MonitorProcess(ctx context.Context, processID string) (*ProcessStatus, error)
}
```

### 6.3 AgentOrchestrator（Agent编排器）

**职责**:
- 协调多个Agent间的协作
- 管理消息的路由和分发
- 处理Agent间的依赖关系

**接口设计**:
```go
type AgentOrchestrator interface {
    CoordinateAgents(ctx context.Context, agents []Agent, task Task) error
    RouteMessage(ctx context.Context, message Message) error
    ResolveDependencies(ctx context.Context, agent Agent) ([]Agent, error)
}
```

### 6.4 ProjectBuilder（项目构建器）

**职责**:
- 组织项目文件的编译顺序
- 管理项目级别的依赖关系
- 生成项目级别的构建产物

**接口设计**:
```go
type ProjectBuilder interface {
    BuildProject(ctx context.Context, project Project) (*BuildResult, error)
    ResolveDependencies(ctx context.Context, project Project) ([]Dependency, error)
    PackageArtifacts(ctx context.Context, buildResult BuildResult) (*Package, error)
}
```

### 6.5 Analyzer（分析器）

**职责**:
- 执行各种类型的代码和性能分析
- 生成分析报告和建议
- 管理分析过程的状态

**接口设计**:
```go
type Analyzer interface {
    AnalyzeCode(ctx context.Context, code string) (*CodeAnalysis, error)
    AnalyzePerformance(ctx context.Context, metrics []Metric) (*PerformanceReport, error)
    GenerateRecommendations(ctx context.Context, analysis Analysis) ([]Recommendation, error)
}
```

## 7. 仓储接口设计

### 7.1 CompilationTaskRepository

```go
type CompilationTaskRepository interface {
    Save(ctx context.Context, task CompilationTask) error
    FindByID(ctx context.Context, id string) (CompilationTask, error)
    FindByStatus(ctx context.Context, status CompilationStatus) ([]CompilationTask, error)
    Update(ctx context.Context, task CompilationTask) error
    Delete(ctx context.Context, id string) error
}
```

### 7.2 ProcessRepository

```go
type ProcessRepository interface {
    Save(ctx context.Context, process Process) error
    FindByID(ctx context.Context, id string) (Process, error)
    FindByStatus(ctx context.Context, status ProcessStatus) ([]Process, error)
    Update(ctx context.Context, process Process) error
    Delete(ctx context.Context, id string) error
}
```

### 7.3 AgentRepository

```go
type AgentRepository interface {
    Save(ctx context.Context, agent Agent) error
    FindByID(ctx context.Context, id string) (Agent, error)
    FindByStatus(ctx context.Context, status AgentStatus) ([]Agent, error)
    Update(ctx context.Context, agent Agent) error
    Delete(ctx context.Context, id string) error
}
```

### 7.4 ProjectRepository

```go
type ProjectRepository interface {
    Save(ctx context.Context, project Project) error
    FindByID(ctx context.Context, id string) (Project, error)
    FindByType(ctx context.Context, projectType ProjectType) ([]Project, error)
    Update(ctx context.Context, project Project) error
    Delete(ctx context.Context, id string) error
}
```

### 7.5 AnalysisRepository

```go
type AnalysisRepository interface {
    Save(ctx context.Context, session AnalysisSession) error
    FindByID(ctx context.Context, id string) (AnalysisSession, error)
    FindByType(ctx context.Context, analysisType AnalysisType) ([]AnalysisSession, error)
    Update(ctx context.Context, session AnalysisSession) error
    Delete(ctx context.Context, id string) error
}
```

## 8. 值对象设计

### 8.1 CompileTarget 值对象

```go
type CompileTarget struct {
    os   string
    arch string
}

func NewCompileTarget(os, arch string) (CompileTarget, error) {
    // 验证操作系统和架构的组合是否有效
    if !isValidCombination(os, arch) {
        return CompileTarget{}, fmt.Errorf("invalid OS-arch combination: %s-%s", os, arch)
    }
    return CompileTarget{os: os, arch: arch}, nil
}

func (t CompileTarget) OS() string   { return t.os }
func (t CompileTarget) Arch() string { return t.arch }
func (t CompileTarget) String() string { return fmt.Sprintf("%s-%s", t.os, t.arch) }
func (t CompileTarget) Equals(other CompileTarget) bool {
    return t.os == other.os && t.arch == other.arch
}
```

### 8.2 AgentStatus 值对象

```go
type AgentStatus struct {
    status string
}

func NewAgentStatus(status string) (AgentStatus, error) {
    validStatuses := []string{"idle", "running", "paused", "error"}
    if !contains(validStatuses, status) {
        return AgentStatus{}, fmt.Errorf("invalid agent status: %s", status)
    }
    return AgentStatus{status: status}, nil
}

func (s AgentStatus) String() string { return s.status }
func (s AgentStatus) IsActive() bool { return s.status == "running" }
func (s AgentStatus) CanTransitionTo(newStatus AgentStatus) bool {
    // 定义状态转换规则
    transitions := map[string][]string{
        "idle":    {"running"},
        "running": {"paused", "error"},
        "paused":  {"running", "idle"},
        "error":   {"idle"},
    }
    allowed, exists := transitions[s.status]
    if !exists {
        return false
    }
    return contains(allowed, newStatus.status)
}
```

## 9. 领域异常设计

### 9.1 CompilationError

```go
type CompilationError struct {
    Type    CompilationErrorType
    Message string
    File    string
    Line    int
    Column  int
}

func (e CompilationError) Error() string {
    return fmt.Sprintf("%s at %s:%d:%d: %s", e.Type, e.File, e.Line, e.Column, e.Message)
}
```

### 9.2 RuntimeError

```go
type RuntimeError struct {
    Type    RuntimeErrorType
    Message string
    ProcessID string
    Timestamp time.Time
}

func (e RuntimeError) Error() string {
    return fmt.Sprintf("[%s] %s: %s", e.Timestamp.Format(time.RFC3339), e.Type, e.Message)
}
```

### 9.3 AgentError

```go
type AgentError struct {
    AgentID string
    Type    AgentErrorType
    Message string
    Context map[string]interface{}
}

func (e AgentError) Error() string {
    return fmt.Sprintf("agent %s error: %s - %s", e.AgentID, e.Type, e.Message)
}
```

## 10. 质量保证

### 10.1 概念完整性检查

- [ ] 所有核心业务概念是否已识别？
- [ ] 概念之间的关系是否明确？
- [ ] 业务规则是否完整表达？
- [ ] 概念是否与统一语言一致？

### 10.2 模型一致性检查

- [ ] 聚合边界是否合理？
- [ ] 实体和值对象区分是否正确？
- [ ] 领域服务职责是否单一？
- [ ] 仓储接口是否完整？

### 10.3 可实现性检查

- [ ] 概念模型是否可直接映射为代码？
- [ ] 领域事件是否支持业务流程？
- [ ] 值对象不变性是否可维护？
- [ ] 聚合一致性边界是否可技术实现？

这个概念模型设计为Echo Language的领域建模提供了完整的基础框架，明确了各限界上下文的核心概念、关系和行为规则，为后续的代码实现提供了清晰的指导。
