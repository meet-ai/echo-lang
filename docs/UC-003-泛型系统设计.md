# UC-003 泛型系统设计

## 🎯 目标

实现Echo语言的泛型系统，支持参数化类型，提高代码复用性和类型安全性。

## 📋 需求分析

### 核心功能
- ✅ 泛型函数：`func identity<T>(value: T) -> T`
- ✅ 泛型结构体：`struct Container<T> { value: T }`
- ✅ 泛型方法：`func (c Container<T>) get() -> T`
- ✅ Trait约束：`func printValue<T: Printable>(value: T)`
- ✅ 类型推断：`identity(42)` 自动推断为 `identity<int>(42)`

### 实现策略
采用**单态化（Monomorphization）**策略：
- 编译时为每个具体类型生成专门的代码
- 运行时无额外开销
- 类型安全保证

## 🏗️ 架构设计

### AST扩展

#### 新增节点类型
```go
// GenericParam 类型参数
type GenericParam struct {
    Name string       // 参数名，如 "T"
    Constraints []string // 约束条件，如 ["Printable", "Serializable"]
}

// GenericType 泛型类型引用
type GenericType struct {
    BaseType string        // 基础类型，如 "Container"
    TypeArgs []string      // 类型参数，如 ["int", "string"]
}

// GenericFuncDef 泛型函数定义
type GenericFuncDef struct {
    Name       string
    TypeParams []GenericParam // 类型参数列表
    Params     []Param
    ReturnType string
    Body       []ASTNode
}

// GenericStructDef 泛型结构体定义
type GenericStructDef struct {
    Name       string
    TypeParams []GenericParam // 类型参数列表
    Fields     []StructField
}
```

#### 扩展现有节点
```go
// FuncDef 扩展支持泛型
type FuncDef struct {
    Name       string
    TypeParams []GenericParam // 新增：类型参数
    Params     []Param
    ReturnType string
    Body       []ASTNode
}

// StructDef 扩展支持泛型
type StructDef struct {
    Name       string
    TypeParams []GenericParam // 新增：类型参数
    Fields     []StructField
}

// MethodDef 扩展支持泛型
type MethodDef struct {
    Receiver      string
    ReceiverVar   string
    TypeParams    []GenericParam // 新增：类型参数
    Name          string
    Params        []Param
    ReturnType    string
    Body          []ASTNode
}
```

### 语法设计

泛型参数使用方括号 `[]` 表示，与数组语法区分：
- 泛型参数：`[T]`、`[T: Trait]`、`[A, B]`
- 数组类型：`[int]`、`[string]`

#### 泛型函数
```rust
// 简单泛型函数
func identity[T](value: T) -> T {
    return value
}

// 带约束的泛型函数
func printValue[T: Printable](value: T) -> void {
    value.print()
}

// 多类型参数
func pair[A, B](a: A, b: B) -> Pair[A, B] {
    return {first: a, second: b}
}
```

#### 泛型结构体
```rust
// 简单泛型结构体
struct Container[T] {
    value: T
}

// 多类型参数
struct Pair[A, B] {
    first: A
    second: B
}

// 带约束的泛型结构体
struct Processor[T: Serializable] {
    data: T
}
```

#### 泛型方法
```rust
struct Container[T] {
    value: T
}

// 泛型方法
func (c Container[T]) get[U]() -> U {
    return c.value as U
}

// 带约束的方法
func (c Container[T]) process[U: Processor]() -> U {
    return U.process(c.value)
}
```

### 类型推断算法

#### 基本推断规则
1. **直接匹配**：`identity[int](42)` → T = int
2. **从参数推断**：`identity(42)` → 从42推断T = int
3. **从返回值推断**：`let x: string = identity("hello")` → T = string
4. **约束检查**：确保推断的类型满足约束条件

#### 推断算法实现
```go
type TypeInference struct {
    // 类型变量映射
    typeVars map[string]string
    // 约束条件
    constraints map[string][]string
}

// InferTypes 执行类型推断
func (ti *TypeInference) InferTypes(funcDef *GenericFuncDef, call *FuncCall) (map[string]string, error) {
    // 1. 从显式类型参数开始
    if len(call.TypeArgs) > 0 {
        for i, arg := range call.TypeArgs {
            ti.typeVars[funcDef.TypeParams[i].Name] = arg
        }
    }
    
    // 2. 从实参推断
    for i, arg := range call.Args {
        paramType := funcDef.Params[i].Type
        inferred := ti.inferFromArg(paramType, arg)
        // ... 推断逻辑
    }
    
    // 3. 检查约束
    return ti.checkConstraints()
}
```

## 🔧 实现步骤

### 阶段1：AST和解析器扩展
1. 定义新的AST节点类型
2. 更新ASTVisitor接口
3. 扩展解析器支持泛型语法
4. 添加类型参数解析逻辑

### 阶段2：类型系统基础
1. 实现类型参数管理
2. 添加约束检查机制
3. 实现基本类型推断

### 阶段3：代码生成
1. 实现单态化算法
2. 更新OCaml代码生成器
3. 处理泛型类型到具体类型的转换

### 阶段4：高级特性
1. 实现复杂的类型推断
2. 支持Trait约束
3. 添加编译时检查

## 🧪 测试策略

### 单元测试
- 泛型函数定义和调用
- 泛型结构体定义和使用
- 类型推断正确性
- 约束检查机制

### 集成测试
- 完整泛型程序编译
- 类型推断在复杂场景下的表现
- 单态化代码生成的正确性

### 边界测试
- 循环依赖检测
- 约束冲突处理
- 类型推断失败的情况

## 📊 成功指标

- [ ] 能编译使用泛型的"Hello Generic"程序
- [ ] 类型推断准确率 > 90%
- [ ] 单态化生成代码正确执行
- [ ] 泛型代码复用率 > 50%

## ⚠️ 风险评估

### 技术风险
- **类型推断复杂度**：需要处理复杂的推断场景
- **单态化开销**：代码大小可能显著增加
- **编译时间**：类型检查和推断会增加编译时间

### 缓解措施
- 从简单场景开始，逐步增加复杂度
- 实现增量编译优化
- 添加详细的错误信息和调试支持

## 🎯 验收标准

### 功能验收
- [ ] 泛型函数定义和调用
- [ ] 泛型结构体定义和实例化
- [ ] 类型参数约束
- [ ] 类型推断机制

### 质量验收
- [ ] 编译错误信息清晰
- [ ] 运行时性能无明显下降
- [ ] 代码生成正确且可读

### 文档验收
- [ ] 泛型语法完整文档
- [ ] 使用示例和最佳实践
- [ ] 常见问题解答

---

## 📝 实现日志

- **2025-01-16**: 创建泛型系统设计文档
- **2025-01-16**: 分析AST扩展需求
- **2025-01-16**: 设计单态化策略
