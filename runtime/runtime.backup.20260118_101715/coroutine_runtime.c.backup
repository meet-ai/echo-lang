#define _XOPEN_SOURCE 600
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <ucontext.h>
#include <unistd.h>
#include <pthread.h>
#include <sched.h>

// GMP模型常量
#define MAX_PROCESSORS 8
#define LOCAL_QUEUE_SIZE 256
#define GLOBAL_QUEUE_SIZE 1024

// 协程状态
typedef enum {
    COROUTINE_READY,
    COROUTINE_RUNNING,
    COROUTINE_SUSPENDED,
    COROUTINE_COMPLETED,
    COROUTINE_FAILED
} CoroutineState;

// Future状态
typedef enum {
    FUTURE_PENDING,
    FUTURE_RESOLVED,
    FUTURE_REJECTED
} FutureState;

// Future结构体
typedef struct Future {
    uint64_t id;
    FutureState state;
    void* value;
    void* error;
    struct Coroutine* waiting_coroutine;  // 等待这个Future的协程
} Future;

// 协程结构体 (G - Goroutine)
typedef struct Coroutine {
    uint64_t id;
    CoroutineState state;
    ucontext_t context;
    char* stack;
    size_t stack_size;
    void (*entry_point)(void*);  // 协程入口函数
    void* arg;                   // 入口函数参数
    struct Processor* bound_processor;  // 绑定到的处理器
} Coroutine;

// 处理器结构体 (P - Processor)
typedef struct Processor {
    uint32_t id;                              // 处理器ID
    Coroutine* local_queue[LOCAL_QUEUE_SIZE]; // 本地协程队列
    uint32_t local_queue_head;                 // 队列头
    uint32_t local_queue_tail;                 // 队列尾
    uint32_t local_queue_size;                 // 队列大小
    pthread_mutex_t lock;                      // 处理器锁
    struct Machine* bound_machine;             // 绑定的机器
} Processor;

// 机器结构体 (M - Machine/OS Thread)
typedef struct Machine {
    uint32_t id;                    // 机器ID
    pthread_t thread;              // OS线程
    Processor* bound_processor;    // 绑定的处理器
    ucontext_t context;            // 机器上下文
    int is_running;                // 是否正在运行
} Machine;

// 全局调度器 (GMP模型)
typedef struct GlobalScheduler {
    // 全局协程队列
    Coroutine* global_queue[GLOBAL_QUEUE_SIZE];
    uint32_t global_queue_head;
    uint32_t global_queue_tail;
    uint32_t global_queue_size;

    // 处理器数组
    Processor processors[MAX_PROCESSORS];
    uint32_t num_processors;

    // 机器数组
    Machine machines[MAX_PROCESSORS];
    uint32_t num_machines;

    // 同步原语
    pthread_mutex_t global_lock;    // 全局锁
    pthread_cond_t work_available;  // 工作可用条件变量

    // ID生成器
    uint64_t next_coroutine_id;
    uint64_t next_future_id;

    int is_running;                 // 调度器是否正在运行
} GlobalScheduler;

// 全局调度器实例
static GlobalScheduler global_scheduler = {0};

// ID生成函数
static uint64_t generate_coroutine_id() {
    pthread_mutex_lock(&global_scheduler.global_lock);
    uint64_t id = global_scheduler.next_coroutine_id++;
    pthread_mutex_unlock(&global_scheduler.global_lock);
    return id;
}

static uint64_t generate_future_id() {
    pthread_mutex_lock(&global_scheduler.global_lock);
    uint64_t id = global_scheduler.next_future_id++;
    pthread_mutex_unlock(&global_scheduler.global_lock);
    return id;
}

// 前向声明
static void coroutine_wrapper(void* arg);
static void* machine_worker(void* arg);
static void processor_schedule(Processor* p);
static Coroutine* processor_get_local_work(Processor* p);
static Coroutine* processor_steal_work(Processor* p);
static void global_scheduler_push(Coroutine* co);
static Coroutine* global_scheduler_pop();
static void processor_push_local(Processor* p, Coroutine* co);
static void global_scheduler_init();
static void processor_init(Processor* p, uint32_t id);
static void machine_init(Machine* m, uint32_t id, Processor* p);

void* future_new();
void future_resolve(void* future_ptr, void* value);
void future_reject(void* future_ptr, void* error);
void* coroutine_spawn(void* entry_func, int32_t arg_count, void* args, void* future_ptr);
void* coroutine_await(void* future_ptr);
void echo_main();
void print_int(int32_t value);
void print_string(char* str);

// 协程入口点包装函数
static void coroutine_wrapper(void* arg) {
    Coroutine* co = (Coroutine*)arg;
    printf("DEBUG: Coroutine %llu started on processor %u\n",
           co->id, co->bound_processor ? co->bound_processor->id : 999);

    // 调用实际的入口函数
    if (co->entry_point) {
        co->entry_point(co->arg);
    }

    // 协程完成
    printf("DEBUG: Coroutine %llu completed\n", co->id);
    co->state = COROUTINE_COMPLETED;

    // 通知等待的协程（如果有的话）
    if (co->arg && ((Future*)co->arg)->waiting_coroutine) {
        Future* future = (Future*)co->arg;
        future->state = FUTURE_RESOLVED;
        future->value = NULL;  // 协程完成，没有返回值

        // 将等待协程重新加入调度队列
        if (future->waiting_coroutine->bound_processor) {
            processor_push_local(future->waiting_coroutine->bound_processor, future->waiting_coroutine);
        }
    }

    // 让出控制权，切换到调度器
    if (co->bound_processor) {
        processor_schedule(co->bound_processor);
    }
}

// 全局调度器初始化
static void global_scheduler_init() {
    static int initialized = 0;
    if (initialized) return;
    initialized = 1;

    printf("DEBUG: Initializing GMP scheduler...\n");

    // 初始化全局锁
    pthread_mutex_init(&global_scheduler.global_lock, NULL);
    pthread_cond_init(&global_scheduler.work_available, NULL);

    // 获取CPU核心数
    int num_cpus = sysconf(_SC_NPROCESSORS_ONLN);
    if (num_cpus > MAX_PROCESSORS) num_cpus = MAX_PROCESSORS;
    global_scheduler.num_processors = num_cpus;
    global_scheduler.num_machines = num_cpus;

    printf("DEBUG: Detected %d CPU cores, creating %d processors and machines\n",
           num_cpus, num_cpus);

    // 初始化处理器和机器
    for (uint32_t i = 0; i < num_cpus; i++) {
        processor_init(&global_scheduler.processors[i], i);
        machine_init(&global_scheduler.machines[i], i, &global_scheduler.processors[i]);
    }

    global_scheduler.next_coroutine_id = 1;
    global_scheduler.next_future_id = 1;
    global_scheduler.is_running = 0;

    printf("DEBUG: GMP scheduler initialized with %d processors\n", num_cpus);
}

// 处理器初始化
static void processor_init(Processor* p, uint32_t id) {
    p->id = id;
    p->local_queue_head = 0;
    p->local_queue_tail = 0;
    p->local_queue_size = 0;
    p->bound_machine = NULL;
    pthread_mutex_init(&p->lock, NULL);

    printf("DEBUG: Processor %u initialized\n", id);
}

// 机器初始化
static void machine_init(Machine* m, uint32_t id, Processor* p) {
    m->id = id;
    m->bound_processor = p;
    p->bound_machine = m;
    m->is_running = 0;

    printf("DEBUG: Machine %u initialized, bound to processor %u\n", id, p->id);
}

// 向运行队列添加协程
static void scheduler_add_coroutine(Coroutine* co) {
    co->next = NULL;
    if (global_scheduler.run_queue_tail == NULL) {
        global_scheduler.run_queue_head = co;
        global_scheduler.run_queue_tail = co;
    } else {
        global_scheduler.run_queue_tail->next = co;
        global_scheduler.run_queue_tail = co;
    }
    printf("DEBUG: Added coroutine %llu to run queue\n", co->id);
}

// 从运行队列移除协程
static Coroutine* scheduler_get_next_coroutine() {
    if (global_scheduler.run_queue_head == NULL) {
        return NULL;
    }

    Coroutine* co = global_scheduler.run_queue_head;
    global_scheduler.run_queue_head = co->next;
    if (global_scheduler.run_queue_head == NULL) {
        global_scheduler.run_queue_tail = NULL;
    }
    co->next = NULL;
    return co;
}

// 协程让出执行权
void scheduler_yield() {
    Coroutine* current = global_scheduler.current;
    if (current == NULL) {
        return;
    }

    // 如果协程还没完成，重新加入队列
    if (current->state == COROUTINE_RUNNING) {
        current->state = COROUTINE_READY;
        scheduler_add_coroutine(current);
    }

    // 切换到下一个协程或主线程
    scheduler_schedule();
}

// 调度下一个协程
void scheduler_schedule() {
    Coroutine* next_co = scheduler_get_next_coroutine();

    if (next_co == NULL) {
        // 没有可运行的协程，切换回主线程
        printf("DEBUG: No more coroutines, returning to main\n");
        global_scheduler.current = NULL;
        setcontext(&global_scheduler.main_context);
        return;
    }

    // 切换到下一个协程
    Coroutine* prev_co = global_scheduler.current;
    global_scheduler.current = next_co;
    next_co->state = COROUTINE_RUNNING;

    printf("DEBUG: Switching from coroutine %llu to %llu\n",
           prev_co ? prev_co->id : 0, next_co->id);

    if (prev_co == NULL) {
        // 从主线程切换到协程
        swapcontext(&global_scheduler.main_context, &next_co->context);
    } else {
        // 从协程切换到协程
        swapcontext(&prev_co->context, &next_co->context);
    }
};

// 全局变量
static uint64_t next_coroutine_id = 1;
static uint64_t next_future_id = 1;




// 创建新Future
void* future_new() {
    Future* future = (Future*)malloc(sizeof(Future));
    if (!future) {
        fprintf(stderr, "Failed to allocate Future\n");
        exit(1);
    }

    future->id = generate_future_id();
    future->state = FUTURE_PENDING;
    future->value = NULL;
    future->error = NULL;
    future->waiting_coroutine = NULL;

    return future;
}

// 解析Future
void future_resolve(void* future_ptr, void* value) {
    printf("DEBUG: future_resolve called for future %p with value %p\n", future_ptr, value);

    Future* future = (Future*)future_ptr;
    if (!future) {
        printf("DEBUG: future_resolve called with NULL future\n");
        return;
    }

    printf("DEBUG: resolving future %llu\n", future->id);

    future->state = FUTURE_RESOLVED;
    future->value = value;

    printf("DEBUG: future %llu resolved to state %d\n", future->id, future->state);

    // 如果有协程在等待这个Future，将其重新加入运行队列
    if (future->waiting_coroutine) {
        printf("DEBUG: Future %llu resolved, waking up coroutine %llu\n",
               future->id, future->waiting_coroutine->id);
        future->waiting_coroutine->state = COROUTINE_READY;
        future->waiting_coroutine->waiting_future = NULL;
        scheduler_add_coroutine(future->waiting_coroutine);
        future->waiting_coroutine = NULL;
    } else {
        printf("DEBUG: no coroutine waiting for future %llu\n", future->id);
    }
}

// 拒绝Future
void future_reject(void* future_ptr, void* error) {
    Future* future = (Future*)future_ptr;
    if (!future) return;

    future->state = FUTURE_REJECTED;
    future->error = error;

    // 即使是错误，也要唤醒等待的协程
    if (future->waiting_coroutine) {
        printf("DEBUG: Future %llu rejected, waking up coroutine %llu\n",
               future->id, future->waiting_coroutine->id);
        scheduler_add_coroutine(future->waiting_coroutine);
        future->waiting_coroutine = NULL;
    }
}

// 等待Future完成（真正的协程版本）
void* coroutine_await(void* future_ptr) {
    Future* future = (Future*)future_ptr;
    if (!future) {
        printf("DEBUG: coroutine_await called with NULL future\n");
        return NULL;
    }

    printf("DEBUG: coroutine_await called for Future %llu, state=%d\n", future->id, future->state);

    // 如果Future已经完成，直接返回结果
    if (future->state == FUTURE_RESOLVED) {
        printf("DEBUG: Future already resolved, returning value\n");
        return future->value;
    }
    if (future->state == FUTURE_REJECTED) {
        printf("DEBUG: Future rejected, returning error\n");
        return future->error;
    }

    // Future还未完成，暂停当前协程
    future->waiting_coroutine = global_scheduler.current;
    global_scheduler.current->state = COROUTINE_SUSPENDED;
    global_scheduler.current->waiting_future = future;

    printf("DEBUG: Suspending coroutine %llu\n", global_scheduler.current->id);

    // 让出执行权，调度器会选择其他协程运行
    scheduler_yield();

    // 当协程被唤醒时，Future应该已经完成了
    printf("DEBUG: Coroutine %llu resumed\n", global_scheduler.current->id);

    if (future->state == FUTURE_RESOLVED) {
        return future->value;
    }
    return NULL;
}

// 启动协程
void* coroutine_spawn(void* entry_func, int32_t arg_count, void* args, void* future_ptr) {
    printf("DEBUG: coroutine_spawn called with entry %p, args %p, future %p\n", entry_func, args, future_ptr);

    // 初始化调度器（如果还没初始化）
    scheduler_init();

    // 使用传入的Future，而不是创建新的
    Future* future = (Future*)future_ptr;
    if (!future) {
        fprintf(stderr, "Invalid future pointer\n");
        return NULL;
    }

    printf("DEBUG: creating coroutine with future %llu\n", future->id);

    // 创建协程，传递Future作为参数
    Coroutine* co = coroutine_create((void (*)(void*))entry_func, future, 64 * 1024);
    if (!co) {
        fprintf(stderr, "Failed to create coroutine\n");
        return NULL;
    }

    printf("DEBUG: coroutine created with id %llu\n", co->id);

    // 启动协程（添加到运行队列）
    coroutine_start(co);

    printf("DEBUG: coroutine started, run_queue_head=%p\n", global_scheduler.run_queue_head);

    // 返回传入的Future
    return future;
}

// 主程序入口（由LLVM IR调用）
void echo_main() {
    printf("DEBUG: echo_main called\n");

    // 初始化调度器
    scheduler_init();

    // 这里将由编译器生成的代码调用
    // 编译器会生成对用户函数的调用

    // 如果有协程需要运行，启动调度器
    if (global_scheduler.run_queue_head) {
        printf("DEBUG: Starting scheduler with pending coroutines\n");
        global_scheduler.is_running = 1;
        scheduler_schedule();  // 开始调度
    }

    printf("DEBUG: echo_main finished\n");
}

// 打印函数
void print_int(int32_t value) {
    printf("%d\n", value);
}

void print_string(char* str) {
    printf("%s\n", str);
}

// 创建新协程
Coroutine* coroutine_create(void (*entry_point)(void*), void* arg, size_t stack_size) {
    pthread_mutex_lock(&scheduler_mutex);

    Coroutine* co = (Coroutine*)malloc(sizeof(Coroutine));
    if (!co) {
        pthread_mutex_unlock(&scheduler_mutex);
        return NULL;
    }

    co->id = global_scheduler.next_coroutine_id++;
    co->state = COROUTINE_READY;
    co->entry_point = entry_point;
    co->arg = arg;
    co->waiting_future = NULL;
    co->next = NULL;

    // 分配栈空间
    co->stack_size = stack_size > 0 ? stack_size : 64 * 1024;  // 默认64KB
    co->stack = (char*)malloc(co->stack_size);
    if (!co->stack) {
        free(co);
        pthread_mutex_unlock(&scheduler_mutex);
        return NULL;
    }

    // 初始化上下文
    getcontext(&co->context);
    co->context.uc_stack.ss_sp = co->stack;
    co->context.uc_stack.ss_size = co->stack_size;
    co->context.uc_stack.ss_flags = 0;
    co->context.uc_link = &global_scheduler.main_context;  // 协程结束时返回主上下文

    // 设置协程入口点
    makecontext(&co->context, (void (*)())coroutine_wrapper, 1, co);

    printf("DEBUG: Created coroutine %llu with stack size %zu\n", co->id, co->stack_size);

    pthread_mutex_unlock(&scheduler_mutex);
    return co;
}

// 销毁协程
void coroutine_destroy(Coroutine* co) {
    if (!co) return;

    pthread_mutex_lock(&scheduler_mutex);
    if (co->stack) {
        free(co->stack);
    }
    free(co);
    pthread_mutex_unlock(&scheduler_mutex);
}

// 启动协程（添加到运行队列）
void coroutine_start(Coroutine* co) {
    if (!co) return;

    pthread_mutex_lock(&scheduler_mutex);
    scheduler_add_coroutine(co);
    pthread_mutex_unlock(&scheduler_mutex);
}

// 运行调度器（启动协程调度循环）
void run_scheduler() {
    printf("DEBUG: run_scheduler called, run_queue_head=%p\n", global_scheduler.run_queue_head);

    // 如果调度器还没初始化，初始化它
    scheduler_init();

    // 设置调度器为运行状态
    global_scheduler.is_running = 1;

    printf("DEBUG: scheduler initialized, is_running=%d\n", global_scheduler.is_running);

    // 开始调度循环
    while (global_scheduler.is_running && global_scheduler.run_queue_head) {
        printf("DEBUG: scheduler loop, run_queue_head=%p\n", global_scheduler.run_queue_head);
        Coroutine* next_co = scheduler_get_next_coroutine();
        printf("DEBUG: next coroutine=%p\n", next_co);
        if (next_co) {
            printf("DEBUG: scheduling to coroutine %llu\n", next_co->id);
            // 直接调度到这个协程
            scheduler_schedule();
        } else {
            printf("DEBUG: no next coroutine, breaking\n");
            // 没有可运行的协程，退出循环
            break;
        }
    }

    printf("DEBUG: run_scheduler finished\n");
}

